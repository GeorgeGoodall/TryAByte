{
  "_from": "endcrypt",
  "_id": "endcrypt@1.2.3",
  "_inBundle": false,
  "_integrity": "sha1-ABR+rpMi1IMS5wREHudTkEafXws=",
  "_location": "/endcrypt",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "endcrypt",
    "fetchSpec": "latest",
    "name": "endcrypt",
    "raw": "endcrypt",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/endcrypt/-/endcrypt-1.2.3.tgz",
  "_shasum": "00147eae9322d48312e704441ee75390469f5f0b",
  "_spec": "endcrypt",
  "_where": "/home/george/Documents/TryAByte",
  "author": {
    "email": "urbanski.andreas@gmail.com",
    "name": "Andreas Urbanski"
  },
  "bugs": {
    "url": "https://github.com/andreasur/endcrypt/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "Easy end-to-end encryption via Diffie-Hellman key-exchange and AES256 encryption",
  "devDependencies": {},
  "keywords": [
    "aes",
    "aes256",
    "decrypt",
    "diffie-hellman",
    "encrypt",
    "end",
    "end-to-end",
    "exchange",
    "key",
    "to"
  ],
  "license": "MIT",
  "main": "endcrypt.js",
  "name": "endcrypt",
  "optionalDependencies": {},
  "readme": "# Endcrypt\n\nEasy end-to-end encryption in Node. This module uses the Diffie-Hellman protocol to exchange secrets between two parties. An AES256 encryption key is derived from the exchange and used to encrypt messages in CBC mode. This module uses cryptographically secure Pseudo-RNG to create private keys on the fly. A 2048-bit base prime is used in the Diffie-Hellman parameter calculation.\n\n*\"Endcrypt rules because it's easy to use, small in size and has no additional dependecies!\"\n-Anonymous*\n\n## Installation\n\nInstall using the node package manager `npm` by issuing\n\n```\nnpm install endcrypt\n```\n\nThen import in your project\n\n```\n// CommonJS import syntax\nvar endcrypt = require(\"endcrypt\")\nnew endcrypt.Endcrypt()\n\n// ES6 import syntax\nimport { Endcrypt } from \"endcrypt\"\nnew Endcrypt()\n```\n\n## Usage\n\nUsing the module is very simple: first you initialize the `Endcrypt` objects, exchange keys and then call the encrypt and decrypt methods.\n\n**Basic example:**\n\n```\n// Let two parties initialize endcrypt\nvar alice = new Endcrypt();\nvar bob = new Endcrypt();\n\n// OPTIONAL: Initialization calls `createKeys()` automatically, so you\n// will already have private and public keys. To regenerate you\n// can call\nalice.createKeys();\n\n// Exchange public keys via callback function; this could\n// be an ajax call or socket.send() or whatever you want\nalice.sendHandshake(function(publicKeyString) {\n  bob.receiveHandshake(publicKeyString)\n});\nbob.sendHandshake(function(publicKeyString) {\n  alice.receiveHandshake(publicKeyString)\n});\n\n// OPTIONAL: If the sendHandshake operation is going to be asynchronous\n// you can use the waitForHandshake() method to trigger success\n// or fail callbacks\nalice.waitForHandshake(\n  function(){\n    console.log(\"Handshake success!\");\n  },\n  function(){\n    console.log(\"Timeout occured!\");\n  },\n  // 10-second timeout\n  10000);\n\n// When a handshake is complete, both parties will have a common\n// AES encryption key\nvar encrypted = alice.encrypt(\"Hello Bob!\");\nvar plain = bob.decrypt(encrypted);\n\nconsole.log(plain) // Will log \"Hello Bob!\"\n\n// Use clear handshake when done with all communication\nalice.clearHandshake();\nbob.clearHandshake();\n```\nDescribed above is the basic scheme to setup end-to-end encryption. But you can easily create custom schemes yourself using the functions provided (see below).\n\n**Simple AES encrypt/decrypt example**\n\n```\n// Initialize the Endcrypt object\nvar e = new Endcrypt();\n\n// Our message to be encrypted\nvar plain = \"Hello world!\";\n\n// Encrypt it (IV is auto-generated)\nvar encrypted = e.encryptWithKey(plain, \"16bytesecretkeys\")\n\n// Log it\nconsole.log(encrypted)\n\n// The output will be similar to\n// {e: \"U2FsdGVkX1/LaoLKb6vyoupV5zTzewZCXTPTJSLgwkQ=\", iv: \"D83V07m3n07G1W0N\"}\n\n// The encrypted message is in .e and the initialization vector in .iv\n\nencrypted.e\nencrypted.iv\n\n// Now decrypt it using the same key\nvar decrypted = e.decryptWithKey(encrypted, \"16bytesecretkeys\");\n\n// Log it\nconsole.log(decrypted)\n\n// The output will be plain string\n// \"Hello world!\"\n\n```\n\n## Randomness\n\nWhen running in a modern web browser the module will use a cryptographically secure `RandomSource.getRandomBytes` for key generation. A fallback to Mersenne-Twister is provided for older browsers.\n\n## Encryption keys\n\nThe `Endcrypt` object stores your encryption keys. The object holds the following keys under normal operation:\n\n```\nprivateKey              // Private key in bigInt raw format\nprivateKeyString        // Private key in string format\npublicKey               // Public key in bigInt raw format\npublicKeyString         // Public key string in Base64 format\nforeignPublicKey        // Trusted party public key in bigInt raw format\nforeignPublicKeyString  // Trusted party public key Base64 format\nencryptionKey           // AES encryption key after successful handshake in string format\n```\n\n## Method summary\n\nA couple of helpful methods provided by the `Endcrypt` object can be used to create custom behavior:\n\n**encryptWithKey(message, key)**  \nUsed to encrypt a plaintext message string with key. Key length must be a multiple of 16 bytes. IV is created on the fly. Outputs a message object in format\n\n```\n{e: <encrypted base64 string>, iv: <initialization vector string>}\n```\n\n**decryptWithKey(encrypted, key)**  \nDecrypts an encrypted message object (see above).\n\n**aesEncrypt(message, key, iv)**\nSimilar to `encryptWithKey` but lets you specify custom iv.\n\n**aesDecrypt(message, key, iv)**  \nSimilar to `decryptWithKey` but lets you specify custom iv and expects message in string format (Base64).\n\n**createIV()**  \nCreates a random 16-byte initialization vector\n\n**createRandomIntStr(complexity)**  \nCreate a cryptographically secure random integer string of a certain complexity.\n\n**sendHandshake(callback)**  \nPasses `publicKeyString` to callback and calls it.\n\n**receiveHandshake(publicKeyString)**  \nCalculates bigInt `foreignPublicKey` from `publicKeyString` and derives an AES encryption key. The encryption key is accessible through `encryptionKey` and both `encrypt` and `decrypt` methods will work after that.\n\n**clearHandshake()**  \nDestroys foreign keys and encryption keys and prepares the object for a new handshake.\n\n**clearEncryptionKey()**  \nDestroy encryption key. WARN: Not totally secure, clear browser cache as well.\n\n**clearForeignKeys()**  \nDestroys foreign public key obtained via handshake.\n",
  "readmeFilename": "README.md",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "1.2.3"
}
